for(i in sort(unique(adf$cohyear))) {
dd <- quantile(base::sample(adf$relcond[which(adf$cohyear == i)], size = 100000, replace = T), c(0.025, 0.975))
bootcond[which(bootcond$cohort_year == i), 'lcc'] <- dd[1]
bootcond[which(bootcond$cohort_year == i), 'ucc'] <- dd[2]
}
rm(i)
## merge fecun and condition data ----
fecun <- merge(fecun, meancond, by = 'cohort_year', all.x = T)
fecun <- merge(fecun, bootcond, by = 'cohort_year', all.x = T)
fecun <- merge(fecun, bootci, by = 'cohort_year', all.x = T)
## plot fecundity ----
ay <- ggplot(fecun, aes(cohort_year, abrate))
ay <- ay + geom_point()
ay <- ay + geom_pointrange(aes(ymin = ablb, ymax = abub))
ay <- ay + theme_bw()
ay
cy <- ggplot(fecun, aes(cohort_year, meancond))
cy <- cy + geom_point()
cy <- cy + geom_pointrange(aes(ymin = lcc, ymax = ucc))
#f <- f + geom_line(aes(cohort_year, abrate))
cy <- cy + theme_bw()
cy
fy <- ggplot(fecun, aes(cohort_year, fecrate))
fy <- fy + geom_point()
fy <- fy + geom_pointrange(aes(ymin = feclb, ymax = fecub))
fy <- fy + theme_bw()
fy
fecun$Capt1<-c(NA,fecun$Cap[1:(length(fecun$Cap)-1)])
fecun$Capt2<-c(NA,NA,fecun$Cap[1:(length(fecun$Cap)-2)])
fecun$ArcCodt1<-c(NA,fecun$ArcCod[1:(length(fecun$ArcCod)-1)])
fecun$ArcCodt2<-c(NA,NA,fecun$ArcCod[1:(length(fecun$ArcCod)-2)])
fecun$Sandt1<-c(NA,fecun$Sand[1:(length(fecun$Sand)-1)])
fecun$Sandt2<-c(NA,NA,fecun$Sand[1:(length(fecun$Sand)-2)])
fecunice <- fecun
fecunice <- subset(fecunice, cohort_year<2014 & cohort_year>1995)
fecunice <- fecunice[order(fecunice$cohort_year),]
fecunice$abrate<-replace(fecunice$abrate,fecunice$abrate==0,1e-6)
pairs(c(fecunice[,c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1')]),upper.panel=points, lower.panel=panelcor,diag.panel=panel.hist)
source("functions/HighstatLibV7.R")
source('functions/panelcor.r')
source("functions/MCMCSupportHighstatV2.R")
setwd('D:/Buren_files/GitHub/PG_Growth/')
source("functions/HighstatLibV7.R")
source('functions/panelcor.r')
source("functions/MCMCSupportHighstatV2.R")
pairs(c(fecunice[,c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1')]),upper.panel=points, lower.panel=panelcor,diag.panel=panel.hist)
names(fecunice)
pairs(c(fecunice[,c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1', 'meancond')]),upper.panel=points, lower.panel=panelcor,diag.panel=panel.hist)
MyVar <- c('abrate','ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
MyXVar <- c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
Mydotplot(fecunicet1[,MyVar])
pairs(fecunicet1[,MyVar], lower.panel = panel.cor)
fecunicet1 <- fecunice[,c('abrate','ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','cohort_year', 'meancond')]
MyVar <- c('abrate','ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
MyXVar <- c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
Mydotplot(fecunicet1[,MyVar])
pairs(fecunicet1[,MyVar], lower.panel = panel.cor)
corvif(fecunicet1[ ,MyXVar])
VIF <-  corvif(fecunicet1[ ,MyXVar])
VIF
names(fecunicet1)
########################################
### This code constructs and fits all submodels starting from a full model - main effects only ####
########################################
## obtain column names
Cols <- names(fecunicet1)
## exclude response variable, weights and year
Cols <- Cols[! Cols %in% c('cohort_year','weight','abrate')]
n <- length(Cols)
## obtain all combinations of explanatory variables
id <- unlist(
lapply(1:n,
function(i)combn(1:n,i,simplify=F)
)
,recursive=F)
## apply these combinations into a formula, with abrate as response variable
Formulas <- sapply(id,function(i)
paste("abrate~",paste(Cols[i],collapse="+"))
)
## number of models to be fitted
nmodels <-  length(Formulas)
## fit all models
allmodelst1 <- lapply(Formulas,function(i)
betareg(as.formula(i),data=fecunicet1,link=linkfn))
## obtain statistics for all models, including the expression of each model
mst1 <- data.frame(modelnum=as.numeric(1:nmodels))
for (i in 1:nrow(mst1)){
mst1$model[i] <- as.character(allmodelst1[[i]]$formula[3])
mst1$N[i] <-   allmodelst1[[i]]$nobs
mst1$K[i] <- length(allmodelst1[[i]]$coefficients$mean)
mst1$pseudorsquared[i] <- round(allmodelst1[[i]]$pseudo.r.squared,4)
mst1$AICc[i] <- AICc(allmodelst1[[i]])
mst1$LH[i] <- (allmodelst1[[i]]$loglik)
}
### compute AICc and other stats for all models
mst1$deltaAICc <- mst1$AICc - min(mst1$AICc)
mst1$wi<-exp(-0.5*mst1$deltaAICc)/sum(exp(-0.5*mst1$deltaAICc))
mst1$er <- max(mst1$wi)/mst1$wi
mst1<-mst1[order(mst1$modelnum),]
mst1<-mst1[order(mst1$AICc),]
mst1[which(mst1$er<10),c('model','deltaAICc','er')]
#Cols <- c(names(fecunicet1tf), names(fecunicet1))
Cols <- c( names(fecunicet1))
Cols <- unique(Cols[! Cols %in% c('cohort_year','weight','abrate')])
relimp <- data.frame(variable=as.character(rep(NA,length(Cols))), wij=as.numeric(rep(NA,length(Cols))), stringsAsFactors = F)
for (i in 1:length(Cols)){
relimp$variable[i] <- Cols[i]
relimp$wij[i] <- sum(mst1[grep(Cols[i],mst1$model),'wi'])
}
relimp <- relimp[rev(order(relimp$wij)),]
library(betareg)
########################################
### This code constructs and fits all submodels starting from a full model - main effects only ####
########################################
## obtain column names
Cols <- names(fecunicet1)
## exclude response variable, weights and year
Cols <- Cols[! Cols %in% c('cohort_year','weight','abrate')]
n <- length(Cols)
## obtain all combinations of explanatory variables
id <- unlist(
lapply(1:n,
function(i)combn(1:n,i,simplify=F)
)
,recursive=F)
## apply these combinations into a formula, with abrate as response variable
Formulas <- sapply(id,function(i)
paste("abrate~",paste(Cols[i],collapse="+"))
)
## number of models to be fitted
nmodels <-  length(Formulas)
## fit all models
allmodelst1 <- lapply(Formulas,function(i)
betareg(as.formula(i),data=fecunicet1,link=linkfn))
## obtain statistics for all models, including the expression of each model
mst1 <- data.frame(modelnum=as.numeric(1:nmodels))
for (i in 1:nrow(mst1)){
mst1$model[i] <- as.character(allmodelst1[[i]]$formula[3])
mst1$N[i] <-   allmodelst1[[i]]$nobs
mst1$K[i] <- length(allmodelst1[[i]]$coefficients$mean)
mst1$pseudorsquared[i] <- round(allmodelst1[[i]]$pseudo.r.squared,4)
mst1$AICc[i] <- AICc(allmodelst1[[i]])
mst1$LH[i] <- (allmodelst1[[i]]$loglik)
}
### compute AICc and other stats for all models
mst1$deltaAICc <- mst1$AICc - min(mst1$AICc)
mst1$wi<-exp(-0.5*mst1$deltaAICc)/sum(exp(-0.5*mst1$deltaAICc))
mst1$er <- max(mst1$wi)/mst1$wi
mst1<-mst1[order(mst1$modelnum),]
mst1<-mst1[order(mst1$AICc),]
mst1[which(mst1$er<10),c('model','deltaAICc','er')]
#Cols <- c(names(fecunicet1tf), names(fecunicet1))
Cols <- c( names(fecunicet1))
Cols <- unique(Cols[! Cols %in% c('cohort_year','weight','abrate')])
relimp <- data.frame(variable=as.character(rep(NA,length(Cols))), wij=as.numeric(rep(NA,length(Cols))), stringsAsFactors = F)
for (i in 1:length(Cols)){
relimp$variable[i] <- Cols[i]
relimp$wij[i] <- sum(mst1[grep(Cols[i],mst1$model),'wi'])
}
relimp <- relimp[rev(order(relimp$wij)),]
linkfn
linkfn <- 'loglog'
########################################
### This code constructs and fits all submodels starting from a full model - main effects only ----
########################################
## define link function
linkfn <- 'loglog'
## obtain column names
Cols <- names(fecunicet1)
## exclude response variable, weights and year
Cols <- Cols[! Cols %in% c('cohort_year','weight','abrate')]
n <- length(Cols)
## obtain all combinations of explanatory variables
id <- unlist(
lapply(1:n,
function(i)combn(1:n,i,simplify=F)
)
,recursive=F)
## apply these combinations into a formula, with abrate as response variable
Formulas <- sapply(id,function(i)
paste("abrate~",paste(Cols[i],collapse="+"))
)
## number of models to be fitted
nmodels <-  length(Formulas)
## fit all models
allmodelst1 <- lapply(Formulas,function(i)
betareg(as.formula(i),data=fecunicet1,link=linkfn))
## obtain statistics for all models, including the expression of each model
mst1 <- data.frame(modelnum=as.numeric(1:nmodels))
for (i in 1:nrow(mst1)){
mst1$model[i] <- as.character(allmodelst1[[i]]$formula[3])
mst1$N[i] <-   allmodelst1[[i]]$nobs
mst1$K[i] <- length(allmodelst1[[i]]$coefficients$mean)
mst1$pseudorsquared[i] <- round(allmodelst1[[i]]$pseudo.r.squared,4)
mst1$AICc[i] <- AICc(allmodelst1[[i]])
mst1$LH[i] <- (allmodelst1[[i]]$loglik)
}
### compute AICc and other stats for all models
mst1$deltaAICc <- mst1$AICc - min(mst1$AICc)
mst1$wi<-exp(-0.5*mst1$deltaAICc)/sum(exp(-0.5*mst1$deltaAICc))
mst1$er <- max(mst1$wi)/mst1$wi
mst1<-mst1[order(mst1$modelnum),]
mst1<-mst1[order(mst1$AICc),]
mst1[which(mst1$er<10),c('model','deltaAICc','er')]
#Cols <- c(names(fecunicet1tf), names(fecunicet1))
Cols <- c( names(fecunicet1))
Cols <- unique(Cols[! Cols %in% c('cohort_year','weight','abrate')])
relimp <- data.frame(variable=as.character(rep(NA,length(Cols))), wij=as.numeric(rep(NA,length(Cols))), stringsAsFactors = F)
for (i in 1:length(Cols)){
relimp$variable[i] <- Cols[i]
relimp$wij[i] <- sum(mst1[grep(Cols[i],mst1$model),'wi'])
}
relimp <- relimp[rev(order(relimp$wij)),]
allmodelst1
library(MuMIn)
library(MuMIn)
########################################
### This code constructs and fits all submodels starting from a full model - main effects only ----
########################################
## define link function
linkfn <- 'loglog'
## obtain column names
Cols <- names(fecunicet1)
## exclude response variable, weights and year
Cols <- Cols[! Cols %in% c('cohort_year','weight','abrate')]
n <- length(Cols)
## obtain all combinations of explanatory variables
id <- unlist(
lapply(1:n,
function(i)combn(1:n,i,simplify=F)
)
,recursive=F)
## apply these combinations into a formula, with abrate as response variable
Formulas <- sapply(id,function(i)
paste("abrate~",paste(Cols[i],collapse="+"))
)
## number of models to be fitted
nmodels <-  length(Formulas)
## fit all models
allmodelst1 <- lapply(Formulas,function(i)
betareg(as.formula(i),data=fecunicet1,link=linkfn))
## obtain statistics for all models, including the expression of each model
mst1 <- data.frame(modelnum=as.numeric(1:nmodels))
for (i in 1:nrow(mst1)){
mst1$model[i] <- as.character(allmodelst1[[i]]$formula[3])
mst1$N[i] <-   allmodelst1[[i]]$nobs
mst1$K[i] <- length(allmodelst1[[i]]$coefficients$mean)
mst1$pseudorsquared[i] <- round(allmodelst1[[i]]$pseudo.r.squared,4)
mst1$AICc[i] <- AICc(allmodelst1[[i]])
mst1$LH[i] <- (allmodelst1[[i]]$loglik)
}
### compute AICc and other stats for all models
mst1$deltaAICc <- mst1$AICc - min(mst1$AICc)
mst1$wi<-exp(-0.5*mst1$deltaAICc)/sum(exp(-0.5*mst1$deltaAICc))
mst1$er <- max(mst1$wi)/mst1$wi
mst1<-mst1[order(mst1$modelnum),]
mst1<-mst1[order(mst1$AICc),]
mst1[which(mst1$er<10),c('model','deltaAICc','er')]
#Cols <- c(names(fecunicet1tf), names(fecunicet1))
Cols <- c( names(fecunicet1))
Cols <- unique(Cols[! Cols %in% c('cohort_year','weight','abrate')])
relimp <- data.frame(variable=as.character(rep(NA,length(Cols))), wij=as.numeric(rep(NA,length(Cols))), stringsAsFactors = F)
for (i in 1:length(Cols)){
relimp$variable[i] <- Cols[i]
relimp$wij[i] <- sum(mst1[grep(Cols[i],mst1$model),'wi'])
}
relimp <- relimp[rev(order(relimp$wij)),]
mst1
relimmp
relimp
mst1[which(mst1$modelnum == 6),]
x <- 1:100
y <- 1-exp(x)
plot(x,y)
y <- 1-log(x)
plot(x,y)
1 - log(fecun$meancond)
plot(1 - log(fecun$meancond))
plot(1 - (fecun$meancond))
plot(fecun$abrate, 1 - (fecun$meancond))
plot(fecun$abrate, 1 - log(fecun$meancond))
plot(fecun$abrate, 1 - (fecun$meancond))
plot(fecun$abrate, log(fecun$meancond))
plot(fecun$meancond, fecun$abrate)
nls(abrate ~ 1-log(meancond), data=fecun)
nls(abrate ~ 1-b1*log(meancond), data=fecun, start=list(b1=1))
fit <- nls(abrate ~ 1-b1*log(meancond), data=fecun, start=list(b1=1))
summary(fit)
xdat <- data.frame(meandcond = min(fecun$meancond):max(fecun$meancond))
min(fecun$meancond):max(fecun$meancond)
xdat <- data.frame(meandcond = min(na.omit(fecun$meancond)):na.omit(max(fecun$meancond)))
min(na.omit(fecun$meancond))
xdat <- data.frame(meandcond = min(na.omit(fecun$meancond)):max(na.omit(fecun$meancond)))
xdat
max(na.omit(fecun$meancond)
)
)min(na.omit(fecun$meancond)):max(na.omit(fecun$meancond))
xdat <- data.frame(meandcond =
seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100)
#### start betaregs ----
fecun$Capt1<-c(NA,fecun$Cap[1:(length(fecun$Cap)-1)])
fecun$Capt2<-c(NA,NA,fecun$Cap[1:(length(fecun$Cap)-2)])
fecun$ArcCodt1<-c(NA,fecun$ArcCod[1:(length(fecun$ArcCod)-1)])
fecun$ArcCodt2<-c(NA,NA,fecun$ArcCod[1:(length(fecun$ArcCod)-2)])
fecun$Sandt1<-c(NA,fecun$Sand[1:(length(fecun$Sand)-1)])
fecun$Sandt2<-c(NA,NA,fecun$Sand[1:(length(fecun$Sand)-2)])
fecunice <- fecun
fecunice <- subset(fecunice, cohort_year<2014 & cohort_year>1995)
fecunice <- fecunice[order(fecunice$cohort_year),]
fecunice$abrate<-replace(fecunice$abrate,fecunice$abrate==0,1e-6)
pairs(c(fecunice[,c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1', 'meancond')]),upper.panel=points, lower.panel=panelcor,diag.panel=panel.hist)
fecunicet1 <- fecunice[,c('abrate','ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','cohort_year', 'meancond')]
#Data exploration
#Outliers
MyVar <- c('abrate','ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
MyXVar <- c('ice.1y.jan','Capt1','ArcCodt1','Sandt1','abratet1','meancond')
Mydotplot(fecunicet1[,MyVar])
#Collinearity
pairs(fecunicet1[,MyVar], lower.panel = panel.cor)
corvif(fecunicet1[ ,MyXVar])
VIF <-  corvif(fecunicet1[ ,MyXVar])
#setwd(outpath)
#write.csv(VIF,'VIF_abrate_review2.csv', row.names=T)
#setwd(inpath)
##
### This code constructs and fits all submodels starting from a full model - main effects only
##
## define link function
linkfn <- 'loglog'
## obtain column names
Cols <- names(fecunicet1)
## exclude response variable, weights and year
Cols <- Cols[! Cols %in% c('cohort_year','weight','abrate')]
n <- length(Cols)
## obtain all combinations of explanatory variables
id <- unlist(
lapply(1:n,
function(i)combn(1:n,i,simplify=F)
)
,recursive=F)
## apply these combinations into a formula, with abrate as response variable
Formulas <- sapply(id,function(i)
paste("abrate~",paste(Cols[i],collapse="+"))
)
## number of models to be fitted
nmodels <-  length(Formulas)
## fit all models
allmodelst1 <- lapply(Formulas,function(i)
betareg(as.formula(i),data=fecunicet1,link=linkfn))
## obtain statistics for all models, including the expression of each model
mst1 <- data.frame(modelnum=as.numeric(1:nmodels))
for (i in 1:nrow(mst1)){
mst1$model[i] <- as.character(allmodelst1[[i]]$formula[3])
mst1$N[i] <-   allmodelst1[[i]]$nobs
mst1$K[i] <- length(allmodelst1[[i]]$coefficients$mean)
mst1$pseudorsquared[i] <- round(allmodelst1[[i]]$pseudo.r.squared,4)
mst1$AICc[i] <- AICc(allmodelst1[[i]])
mst1$LH[i] <- (allmodelst1[[i]]$loglik)
}
### compute AICc and other stats for all models
mst1$deltaAICc <- mst1$AICc - min(mst1$AICc)
mst1$wi<-exp(-0.5*mst1$deltaAICc)/sum(exp(-0.5*mst1$deltaAICc))
mst1$er <- max(mst1$wi)/mst1$wi
mst1<-mst1[order(mst1$modelnum),]
mst1<-mst1[order(mst1$AICc),]
mst1[which(mst1$er<10),c('model','deltaAICc','er')]
#Cols <- c(names(fecunicet1tf), names(fecunicet1))
Cols <- c( names(fecunicet1))
Cols <- unique(Cols[! Cols %in% c('cohort_year','weight','abrate')])
relimp <- data.frame(variable=as.character(rep(NA,length(Cols))), wij=as.numeric(rep(NA,length(Cols))), stringsAsFactors = F)
for (i in 1:length(Cols)){
relimp$variable[i] <- Cols[i]
relimp$wij[i] <- sum(mst1[grep(Cols[i],mst1$model),'wi'])
}
relimp <- relimp[rev(order(relimp$wij)),]
xdat <- data.frame(meandcond =
seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100))
xdat
predict(fit, newdata = xdat)
plot(abrate ~ meancond, data = fecun)
plot(abrate ~ meancond, data = fecun, pch =16)
lines(Eabrate ~ meancond, data = xdat)
xdat$Eabrate <- predict(fit, newdata = xdat)
plot(abrate ~ meancond, data = fecun, pch =16)
lines(predict(fit) ~ fecun$meancond)
predict(fit)
fitted(fit)
fecun$meancond
na.omit(fecun$meancond)
lines(predict(fit) ~ na.omit(fecun$meancond))
fit
fit$b1
coef(fit)
lines(1-(b1)coef(fit))*log(meancond) ~ (fecun$meancond))
lines( 1 - (coef(fit))*log(meancond) ~ (fecun$meancond))
1 - (coef(fit))*log(meancond)
1 - (coef(fit))*log(fecun$meancond)
(fecun$meancond)
plot(abrate ~ meancond, data = fecun, pch =16)
lines( 1 - (coef(fit))*log(fecun$meancond) ~ (fecun$meancond))
1 - (coef(fit))*log(fecun$meancond)
fecun$abrate
plot(abrate ~ log(meancond), data = fecun, pch =16)
plot(log(abrate) ~ (meancond), data = fecun, pch =16)
lm(log(abrate) ~ meancond, data = fecun)
ff <- na.omit(fecun[,c('abrate','meancond'),])
lm(log(abrate) ~ meancond, data = ff)
ff
summary(lm(log(y) ~ time, data = x, subset = Factor))
log(0)
1e-16
log(1e-16)
ff$abrata[which(ff$abrate == 0)] <- 1e-16
ff <- na.omit(fecun[,c('abrate','meancond'),])
ff$abrata[which(ff$abrate == 0)] <- 1e-16
ff <- na.omit(fecun[,c('abrate','meancond'),])
ff
ff$abrate[which(ff$abrate == 0)] <- 1e-16
lm(log(abrate) ~ meancond, data = ff)
plot(lm(log(abrate) ~ meancond, data = ff))
fitted(log(abrate) ~ meancond, data = ff)
fitted(lm(log(abrate) ~ meancond, data = ff))
lines( fitted(lm(log(abrate) ~ meancond, data = ff)) ~ (ff$meancond))
plot(log(abrate) ~ (meancond), data = fecun, pch =16)
lines( fitted(lm(log(abrate) ~ meancond, data = ff)) ~ (ff$meancond))
xdat$Eabrate <- predict(f1, newdata = xdat)
f1 <- (lm(log(abrate) ~ meancond, data = ff))
xdat$Eabrate <- predict(f1, newdata = xdat)
predict(f1, newdata = xdat)
xdat$Eabrate <- predict(f1, new.data = xdat)
?predict
xdat$Eabrate <- predict(f1, newdata = xdat, type = 'response')
predict(f1, newdata = xdat, type = 'response')
xdat <- data.frame(meandcond = seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100))
xdat
coef(f1)
xdat$Eabrate <- coef(f1)[1]+coef(f1)[2]*xdat$meandcond
xdat
plot(log(abrate) ~ (meancond), data = fecun, pch =16)
lines( fitted(lm(log(abrate) ~ meancond, data = ff)) ~ (ff$meancond))
lines( Eabrate ~ meancond, data = xdat))
lines( Eabrate ~ meancond, data = xdat)
xdaat
xdat
plot(xdat)
plot(xdat, type = 'l')
points(log(abrate) ~ (meancond), data = fecun, pch =16)
plot(xdat, type = 'l')
points(log(abrate) ~ (meancond), data = ff, pch =16)
plot(log(abrate) ~ meancond, data = fecun, pch =16)
f1 <- (lm(log(abrate) ~ meancond, data = ff))
f1
coef(f1)[1]
coef(f1)[2]
1 - log(fecun$meancond)
exponential.model <- lm(log(abrate) ~  meancond, data = ff)
exponential.model
f1
timevalues <- seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100)
timevalues
exp(predict(exponential.model,list(meancond=timevalues)))
plot(meancond, abrate, data = ff, pch=16)
plot(ff$meancond, ff$abrate, pch=16)
Counts.exponential2 <- exp(predict(exponential.model,list(meancond=timevalues)))
plot(ff$meancond, ff$abrate, pch=16)
lines(timevalues, Counts.exponential2,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
exponential.model <- lm(log(abrate) ~  meancond, data = ff)
condvalues <- seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100)
abrate.exponential <- exp(predict(exponential.model,list(meancond=condvalues)))
plot(ff$meancond, ff$abrate, pch=16)
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
ff <- na.omit(fecun[,c('abrate','meancond'),])
exponential.model <- lm(log(abrate) ~  meancond, data = ff)
condvalues <- seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100)
ff <- na.omit(fecun[,c('abrate','meancond'),])
ff$abrate[which(ff$abrate == 0)] <- 1e-16
exponential.model <- lm(log(abrate) ~  meancond, data = ff)
condvalues <- seq(min(na.omit(fecun$meancond)), max(na.omit(fecun$meancond)), length.out = 100)
abrate.exponential <- exp(predict(exponential.model,list(meancond=condvalues)))
plot(ff$meancond, ff$abrate, pch=16)
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
exponential.model
condvalues <- seq(0, 1.5, length.out = 100)
abrate.exponential <- exp(predict(exponential.model,list(meancond=condvalues)))
plot(ff$meancond, ff$abrate, pch=16)
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
plot(ff$meancond, ff$abrate, pch=16, xlim = c(0, 1.5))
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
plot(ff$meancond, ff$abrate, pch=16, xlim = c(0.9, 1.5))
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
plot(ff$meancond, ff$abrate, pch=16, xlim = c(0.8, 1.5))
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
plot(ff$meancond, ff$abrate, pch=16, xlim = c(0.8, 1.2))
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
fecun[which(fecun$meancond < 0.9)]
fecun[which(fecun$meancond < 0.9),]
ff[which(ff$abrate == 0 & meancond > 0.83),]
ff[which(ff$abrate == 0 & ff$meancond > 0.83),]
ff <- na.omit(fecun[,c('abrate','meancond'),])
ff[which(ff$abrate == 0 & ff$meancond > 0.83),]
ff[which(ff$abrate == 0 & ff$meancond < 0.83),]
ff[which(ff$abrate == 0 & ff$meancond < 0.88),]
ff[which(ff$abrate == 0 & ff$meancond < 0.9),]
ff[which(ff$abrate == 0 & ff$meancond < 0.9), 'meancond']
ff <- na.omit(fecun[,c('abrate','meancond'),])
ff[which(ff$abrate == 0 & ff$meancond < 0.9), 'meancond'] <- NA
ff$abrate[which(ff$abrate == 0)] <- 1e-16
exponential.model <- lm(log(abrate) ~  meancond, data = ff)
condvalues <- seq(0, 1.5, length.out = 100)
abrate.exponential <- exp(predict(exponential.model,list(meancond=condvalues)))
plot(ff$meancond, ff$abrate, pch=16, xlim = c(0.8, 1.2))
lines(condvalues, abrate.exponential,lwd=2, col = "red", xlab = "Time (s)", ylab = "Counts")
